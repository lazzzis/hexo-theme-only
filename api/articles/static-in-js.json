{"title":"在JS中实现静态变量/函数","slug":"static-in-js","date":"2015-10-30T04:54:13.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<h2 id=\"静态变量-方法\"><a href=\"#静态变量-方法\" class=\"headerlink\" title=\"静态变量/方法\"></a>静态变量/方法</h2><p>静态变量/方法，一般来说是独立於对象的存在，它不属於任何一个具体的对象，它属於每一特定类的所有对象。也可以认为是属於一个类的。静态变量一般用於常数，或者存储某一类的所有对象需要共有的变量。<br>学JS的时候发现，与JAVA，C++相比，JS并没有明确定义静态的声明或使用方法。虽然没有说，但仍然需要，比如一个很经典的需要就时用静态变量统计一个类被实例化了几次。</p>\n<h2 id=\"静态变量的实现\"><a href=\"#静态变量的实现\" class=\"headerlink\" title=\"静态变量的实现\"></a>静态变量的实现</h2><p>因为 <code>Function</code> 本身也可以看作是对象，那么就可以尝试给这个对象添加一个常量。例如：</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span><span class=\"hljs-params\">()</span> </span>{\n\n}\nA.count = <span class=\"hljs-number\">0</span>;\n</code></pre>\n<p>那这个<code> count </code>变量就可以看作是专属於 A 的一个变量，而不属於任何一个 A 的对象。比如<code>var a = new A(); console.log(a.count);</code>，此时浏览器的控制台就很清楚地说，对於 a 来说 count 属於 undefined。<br>变量定义好了，接着就时如何实现每一次实例化 count 就会自动加 1 的操作了。如果要每一次实例化的时候 count 加一，就相当於每一次执行函数<code> A </code>的时候就要执行<code> count++; </code>的操作。所以可以将语句放在函数里:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span> A() {\n    A.<span class=\"hljs-built_in\">count</span> ++;\n    // <span class=\"hljs-built_in\">count</span> ++;\n}\nA.<span class=\"hljs-built_in\">count</span> = <span class=\"hljs-number\">0</span>;\n</code></pre>\n<p>注意注释掉的语句，因为如果没有指定 A， 也没有使用 var 声明 count， 那麽JS 会把这个 count 当作是全局变量，很有可能发生由於<code>undefined</code>引起的错误。<br>现在可以测试一下效果了:</p>\n\n    <pre><code class=\"lang-js\">A.count = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span></span>() {\n    A.count ++;\n}\n\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">A</span>();\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">A</span>();\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">A</span>();\nconsole.log(A.count);\n</code></pre>\n<p>在浏览器里运行可以发现，控制台正确的输出了结果3.<br>顺便一提的是，<code>A.count = 0;</code>这条语句既可以写在 <code>function A</code>的定义之前，也可以写在其函数定义之後。因为 JS 有 Hoisting 机制 (可以参考 <a href=\"http://www.w3schools.com/js/js_hoisting.asp\" target=\"_blank\" rel=\"external\">Here</a>)。函数的声明会被自动调到顶端，因此不必过分纠结写在函数定义前或定义之後的问题。</p>\n<h2 id=\"静态方法的实现\"><a href=\"#静态方法的实现\" class=\"headerlink\" title=\"静态方法的实现\"></a>静态方法的实现</h2><p>其实知道了JS中静态变量的实现，那麽实现静态方法也是很简单的事了。根据同样的方法，向函数 A 添加一个方法即可：</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>{\n}\nA.sayho = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Ho!\"</span>);\n}\n\nA.sayho();\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> A();\na.sayho();\n</code></pre>\n<p>此时，也就可以看见控制台输出了一句 “Ho！”。同样，因为这属于静态方法，不属于任何一个具体的实例，因此对于实例化的变量 a 来说，sayho() 方法是未定义的，会报出一个 <code>a.sayho is not a function</code>的错误。</p>\n","categories":[{"name":"Front-end","path":"api/categories/Front-end.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]}