{"title":"在初学JS时犯的一些错误","slug":"mis-in-js","date":"2015-10-24T12:18:27.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<p>表示最近在学JS, 相对个人以前学的Python, JAVA之类的语言, JS的语言确实有一些”奇葩”. 把初学时的一些语法错误记录下来,方便自己以后查阅, 如果能帮助到读这篇文章的你自然就更好了.</p>\n<h2 id=\"number-与-string-相加-减-乘-除\"><a href=\"#number-与-string-相加-减-乘-除\" class=\"headerlink\" title=\"number 与 string 相加/减/乘/除\"></a>number 与 string 相加/减/乘/除</h2><h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1:\"></a>Example 1:</h3>\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a  = <span class=\"hljs-string\">\"5\"</span> + <span class=\"hljs-number\">2</span>;   // the <span class=\"hljs-literal\">result</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-string\">\"52\"</span>\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span> + <span class=\"hljs-string\">\"5\"</span>;    // the <span class=\"hljs-literal\">result</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-string\">\"25\"</span>\n</code></pre>\n<p>在 number 与 string 相加时, number 会被转化为 string, 然后这两个字符串会根据前后顺序做拼接. 这一点上, 有点类似与 JAVA 中的<code>System.out.println(2 + “5”);</code>, 数字遇到加号时会变为字符串,让后做拼接运算.</p>\n<h3 id=\"Example-2\"><a href=\"#Example-2\" class=\"headerlink\" title=\"Example 2:\"></a>Example 2:</h3>\n    <pre><code class=\"lang-js\">var a  = <span class=\"hljs-string\">\"5\"</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>;   <span class=\"hljs-comment\">// the result is \"522\"</span>\nvar b = <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-string\">\"5\"</span>;    <span class=\"hljs-comment\">// the result is \"45\"</span>\n</code></pre>\n<p>如果在 string 前有 number 的运算, 那么 number 仍然会进行正常的 number 之前的运算,直到遇到 string, number 才会 被转为 string.<br>反过来, 如果在 number 前线遇到了 string, 那么后续的每一个 number 都会被当作 string 进行运算.<br>如果对 JAVA 熟悉一点, 这一点也还好理解, 这跟JAVA中<code>System.out.println(2 + 2 + “5”);</code>和<code>System.out.println(“5” + 2 + 2);</code>的结果也是一样的.</p>\n<h3 id=\"Example-3\"><a href=\"#Example-3\" class=\"headerlink\" title=\"Example 3:\"></a>Example 3:</h3>\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-string\">\"5\"</span> - <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// the result is 3</span>\n<span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-string\">\"5\"</span> * <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// the result is 10</span>\n<span class=\"hljs-keyword\">var</span> z = <span class=\"hljs-string\">\"5\"</span> / <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// the result is 2.5</span>\n</code></pre>\n<p>比起加法, 减/乘/除 相对更简单一点,只要 string 能转化为 number, 那么 string 就会转化为 numner 进行运算.</p>\n<h2 id=\"Undefined-不是-Null\"><a href=\"#Undefined-不是-Null\" class=\"headerlink\" title=\"Undefined 不是 Null\"></a>Undefined 不是 Null</h2><p>在 JS 中, null 更多是针对 objects 而言的, 而 undefined 则更多是针对 variables, properties, methods 而言的.<br>要变成null, 一个 object 首先要被定义, 否则只能变成 undefined.</p>\n<p>因此 如果要判断一个 object 是否存在(不为空 且 已被定义),那么以下发发是<strong>错</strong>的:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (myObj !== <span class=\"hljs-literal\">null</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> myObj !== <span class=\"hljs-string\">\"undefined\"</span>)\n</code></pre>\n<p>这样的结果则是<code> Uncaught ReferenceError: myObj is not defined(…) </code><br>所以 要判断是否为 null 前必须要判断是否 已被定义, 所以调换以下判断顺序就可以解决上面的问题了:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> myObj !== <span class=\"hljs-string\">\"undefined\"</span> &amp;&amp; myObj !== <span class=\"hljs-literal\">null</span>)\n</code></pre>\n<p>只有 myObj 被定义了 且 不为 null 时, 上述判断语句才能被盘为 true, 否则均为 false.</p>\n<h2 id=\"向Array添加元素的方式\"><a href=\"#向Array添加元素的方式\" class=\"headerlink\" title=\"向Array添加元素的方式\"></a>向Array添加元素的方式</h2><p>如果已知一个数组<code>arr = [1, 2, 3]</code>, 那么向它的末尾添加元素的方式至少有以下三种：</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example:\"></a>Example:</h3>\n    <pre><code class=\"lang-js\">arr[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">4</span>; <span class=\"hljs-comment\">// 方法1</span>\narr[arr.length] = <span class=\"hljs-number\">4</span>; <span class=\"hljs-comment\">// 方法2</span>\narr.push(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 方法3</span>\n</code></pre>\n<p>虽然这三种都可以完成预期目标，但<strong>极不推荐方法1</strong>，原因是用数字索引很容易产生不期望的错误，仍旧以<code>arr = [1, 2, 3]</code>为例。假设 我不小心写成了<code>arr[4] = 4</code>会怎样呢？实际结果是<code>arr</code>会变成:</p>\n\n    <pre><code class=\"lang-js\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, undefined, <span class=\"hljs-number\">4</span>]\n</code></pre>\n<p>可以看出，JS在此时会自动填充undefined。所以为了避免这种情况的发生，<strong>强烈建议</strong>采用方法2和方法3向数组末尾添加元素.</p>\n<h2 id=\"断开的-return-语句\"><a href=\"#断开的-return-语句\" class=\"headerlink\" title=\"断开的 return 语句\"></a>断开的 return 语句</h2><h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example:\"></a>Example:</h3>\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFun</span>() {\n    <span class=\"hljs-keyword\">return</span>\n        <span class=\"hljs-type\">10</span>;\n}\n</code></pre>\n<p>猜猜调用 myFun() 时, 它会返回什么 ? 经测试正解是 undefined .<br>原因是 JS 是这样解释的:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFun</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> ;  <span class=\"hljs-comment\">// Attention</span>\n        <span class=\"hljs-number\">10</span>;\n}\n</code></pre>\n<p>JS 会在那一行的末尾自动补上一个分号以示结束. 所以结果自然是 undefined.</p>\n<h2 id=\"Switch-的严格比较\"><a href=\"#Switch-的严格比较\" class=\"headerlink\" title=\"Switch 的严格比较\"></a>Switch 的严格比较</h2><p>先看例子:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">switch</span> (x) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"10\"</span>:\n        <span class=\"hljs-built_in\">window</span>.alert(<span class=\"hljs-string\">\"run in case\"</span>);\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n        <span class=\"hljs-built_in\">window</span>.alert(<span class=\"hljs-string\">\"run in default\"</span>);\n        <span class=\"hljs-keyword\">break</span>;\n}\n</code></pre>\n<p>在这个例子中, 网页跳出的弹窗中会显示那条信息呢?经测试, 是后一条(“run in default”),而不是前一条(“run in case”).<br>原因很简单, <code>10 === “10” </code>是 false. 所以 不能进入第一个case, 最终会进入到 default 中.</p>\n<h2 id=\"精度的损失\"><a href=\"#精度的损失\" class=\"headerlink\" title=\"精度的损失\"></a>精度的损失</h2><p>不管是什么语言, 浮点数的精度损失不可避免,有的损失比较小, 可以不用太在意,而有的损失可能就比较大,需要额外的注意.<br>Example:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">0.1</span>;\n<span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">0.2</span>\n<span class=\"hljs-keyword\">var</span> z = x + y;\n<span class=\"hljs-built_in\">console</span>.log(z);\n<span class=\"hljs-keyword\">if</span> (z == <span class=\"hljs-number\">0.3</span>) {\n    <span class=\"hljs-built_in\">window</span>.alert(<span class=\"hljs-string\">\"Run\"</span>);\n}\n</code></pre>\n<p>我经过实际运行可以发现 z 的 值其实是 0.30000000000000004 . 跟期望的有点出入. 所以在实际运行网页上不会有弹窗出现.<br>就算是写成 <code>var z = 0.1 + 0.2;</code>也只是换汤不换药.<br>除非直接写成 <code> var z = 0.3 </code><br>如果需要要到x, y变量是可以考虑这么写:</p>\n\n    <pre><code class=\"lang-js\">var z = (x * <span class=\"hljs-number\">10</span> + y * <span class=\"hljs-number\">10</span>) / <span class=\"hljs-number\">10</span>;       <span class=\"hljs-comment\">// z will be 0.3</span>\n</code></pre>\n<h2 id=\"object-之间不能比较\"><a href=\"#object-之间不能比较\" class=\"headerlink\" title=\"object 之间不能比较\"></a>object 之间不能比较</h2><p>Example:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">\"John\"</span>);\n<span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">\"John\"</span>);\n\n<span class=\"hljs-comment\">// (x == y) false, different objects</span>\n<span class=\"hljs-comment\">// (x == x) true, same objects</span>\n<span class=\"hljs-comment\">// (x === y) true</span>\n</code></pre>\n<p>从中也可以看出，对于 string, <strong>极不建议</strong>用构造对象的方式声明.</p>\n<h2 id=\"script-放在head-中还是-body-中\"><a href=\"#script-放在head-中还是-body-中\" class=\"headerlink\" title=\"script 放在head 中还是 body 中\"></a>script 放在head 中还是 body 中</h2><p>理论上讲，把JS放在哪都可以运行，但最近我个人在学习过程中就遇到了一个因放置位置而引起的问题。<br>就我个人编写的下面这个例子来说</p>\n\n    <pre><code class=\"lang-html\">   <span class=\"hljs-meta\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/1999/xhtml\"</span> <span class=\"hljs-attr\">xml:lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n     <span class=\"hljs-comment\">&lt;!-- 1 &lt;script&gt;\n        var demo = document.getElementById(\"demo\");\n        window.alert(demo);\n    &lt;/script&gt; --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 2 &lt;script&gt;\n        var demo = document.getElementById(\"demo\");\n        window.alert(demo);\n    &lt;/script&gt; --&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>如果是写在1处，那么结果是窗口弹出 null，但如果是2处，则正确取到了对象。google之后的结果是：放在 head 和 body 处各有千秋，不能一概而论。但至少如果是放在body里的话，能使 html 的加载在 js 前，相对而言，能使 html 免于因 js 加载受阻而造成影响。所以，在这里只能是先提个醒了，如果放在 head 中运行异常的话，可以试试放在 body 处。</p>\n<h2 id=\"a标签的文本如何不做跳转\"><a href=\"#a标签的文本如何不做跳转\" class=\"headerlink\" title=\"a标签的文本如何不做跳转\"></a>a标签的文本如何不做跳转</h2><p>少数时候不希望被 a 标签包围的文本被点击后做跳转, 只希望停留在当前页面, 也不是重新载入至当前页面.<br>此时需要在 a 标签的 href 属性里如下写:</p>\n\n    <pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"javascript:;\"</span>&gt;</span>Text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></pre>\n<h2 id=\"删除元素应由其父级进行操作\"><a href=\"#删除元素应由其父级进行操作\" class=\"headerlink\" title=\"删除元素应由其父级进行操作\"></a>删除元素应由其父级进行操作</h2><p>在进行DOM操作时，如果要删除某一元素，如：</p>\n\n    <pre><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"target\"</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>要删除 id 为 target 的 li 标签，那么应由其父级对他删除, 而获取其父级则可以通过调用其 parentNode 属性：</p>\n\n    <pre><code class=\"lang-js\">var <span class=\"hljs-keyword\">target</span> = document.getElementById(<span class=\"hljs-string\">'target'</span>);\n<span class=\"hljs-keyword\">target</span>.parentNode.removeChild(<span class=\"hljs-keyword\">target</span>);\n</code></pre>\n<p>而以下是我初学是犯的低级<strong>错误</strong>:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'target'</span>);\n<span class=\"hljs-built_in\">document</span>.body.removeChild(target);\n</code></pre>\n<p>参考资料 : <a href=\"http://www.w3schools.com/js/js_mistakes.asp\" target=\"_blank\" rel=\"external\">w3schoold</a></p>\n","categories":[{"name":"Front-end","path":"api/categories/Front-end.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]}