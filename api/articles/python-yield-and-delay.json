{"title":"延迟计算: 关于 Python 的 yield","slug":"python-yield-and-delay","date":"2016-12-12T13:07:06.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<p>在 SICP 第 3 章中，有一段部分内容是以 stream 为核心而展开的。而 stream 的特点就是 lazy evaluation / delayed evaluation （惰性求值 / 延迟计算）。在接触 stream 之时，我便立即联想到 Python 具有类似的功能 — <code>yield</code>。</p>\n<h1 id=\"yield-的意义\"><a href=\"#yield-的意义\" class=\"headerlink\" title=\"yield 的意义\"></a>yield 的意义</h1><p>使用 yield 的目的是为了生成器，而使用生成器的一个特点是每次只向你返回一个结果。基于这个特点，生成器可以产生的结果数量甚至可以是无限的。因此，生成器在用于表示一些 <code>list</code> 不便或无法表示的超多元素的集合时将表现出很好的便捷性。</p>\n<p>例如:</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">In</span> [68]: def fib():\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     former, latter = 0, 1\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     yield former\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     yield latter\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         former, latter = latter, latter + former\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         yield latter\n\n<span class=\"hljs-keyword\">In</span> [69]: select = lambda x :x <span class=\"hljs-keyword\">and</span> x % 1377 == 0\n\n<span class=\"hljs-keyword\">In</span> [70]: <span class=\"hljs-keyword\">for</span> i, item <span class=\"hljs-keyword\">in</span> enumerate(fib()):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     <span class=\"hljs-keyword\">if</span> select(item):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         <span class=\"hljs-builtin-name\">print</span>(i, item)\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         break\n</code></pre>\n<p>在这里，我先定义了一个生成器函数 fib，用于生成 fibonacci 数列，以及另一个普通函数 select，用于筛选出能被 1377 整除的数。接着用一个循环找出第一个满足 select 的条件的数。在这里，使用生成器的好处是你不需要实现估计需要计算多少个 fibonacci 数列中的元素。因为 fib() 可以产生第无穷个 fibonacci 数列中的元素，加入你换成一个 <code>list</code>：</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">In</span> [70]: <span class=\"hljs-keyword\">for</span> i, item <span class=\"hljs-keyword\">in</span> enumerate(fib_lst):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     <span class=\"hljs-keyword\">if</span> select(item):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         <span class=\"hljs-builtin-name\">print</span>(i, item)\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         break\n</code></pre>\n<p>这里就有一个明显的顾虑：fib_lst 中应该放多少个元素？放 100 个够不够？1000 个呢？10000 个呢？</p>\n<p>假使你运气好，发现对于例子中 select 函数， 1000 个够了，但如果更改 select 为 <code>lambda x: x and x % 3119 == 0</code>。那么 1000 个还会够么。可能需要 10000 个。同时，你每次生成 10000 个甚至 1000000 个元素的列表，那么生成和保存一个如此大的列表在时间上和空间上会使巨大的浪费。而相比于此，生成器没有保存所有元素，因此至少在空间上有极大的便利。</p>\n<h2 id=\"Q：不用生成器，不也有办法达到类似的效果么？\"><a href=\"#Q：不用生成器，不也有办法达到类似的效果么？\" class=\"headerlink\" title=\"Q：不用生成器，不也有办法达到类似的效果么？\"></a>Q：不用生成器，不也有办法达到类似的效果么？</h2><p>或许有人会举出这么一个反例，既然 fib() 函数产生的生成器只是每次临时计算而已，那不用列表或生成器不也有办法可以很方便么？例如:</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">In</span> [63]: former, latter = 0, 1\n\n<span class=\"hljs-keyword\">In</span> [64]: i = 2\n\n<span class=\"hljs-keyword\">In</span> [65]: <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     former, latter = latter, former + latter\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     <span class=\"hljs-keyword\">if</span> select(latter):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         <span class=\"hljs-builtin-name\">print</span>(i, latter)\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         break\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     i += 1\n</code></pre>\n<p>虽然这个方法也可以，但是仔细想想，这个方法的可读性和可移植性说不上很好。一个原因是在进行 select 的代码中糅合了 fibonacci 数列元素计算的过程，使得逻辑上分离的两个部分连在了一起。另一个原因是，生成器将 fibonacci 数列的元素进行了封装，那么在其他模块中也只需要用 fib() 即可调用；而在这个方法中，每一次计算 fibonacci 数列都需要重新写一遍计算的代码，欠缺方便。</p>\n<h2 id=\"写法优化\"><a href=\"#写法优化\" class=\"headerlink\" title=\"写法优化\"></a>写法优化</h2><p>在上例中，我用一个简单的循环求得了第一个满足要求的元素。而在 Python 中，大多简单的循环又可以写成类似列表表达式的方式，而上一个例子也是如此。</p>\n\n    <pre><code class=\"lang-python\">In [<span class=\"hljs-number\">74</span>]: next((<span class=\"hljs-selector-tag\">i</span>, item) <span class=\"hljs-keyword\">for</span> <span class=\"hljs-selector-tag\">i</span>, item <span class=\"hljs-keyword\">in</span> enumerate(fib()) <span class=\"hljs-keyword\">if</span> select(item))\n</code></pre>\n<p>在这里，<code>(i, item) for i, item in enumerate(fib()) if select(item)</code> 本身代表了一个生成器表达式</p>\n<pre><code>In [77]: ((i, item) for i, item in enumerate(fib()) if select(item))\nOut[77]: &lt;generator object &lt;genexpr&gt; at 0x104674258&gt;\n\nIn [78]: gen = ((i, item) for i, item in enumerate(fib()) if select(item))\n\nIn [79]: next(gen)\nOut[79]:\n(1316,\n 47670484598039529967308137755285220283067857159635666308572483292852087741971817495430736032322993914141991666526048221816855193212853932963317951773586445466676607895893764927922577383975888691399916203755485478472365658305444586740978034474331219811230599774368887776557837)\n\nIn [80]: next(gen)\nOut[80]:\n(2632,\n 5081408804827217679483690811505190320468896152614650981083661467793773636093281628433780640132913496539149358258875736128851767346736337537150191351612842042674073125589815465376413058371692145091298387648676549040287922078680500401041910184918357118604215905739580720823641807065276860800035024575275858699179043965222324466320661415297713837965844699076750589037980732572303226178214876864049241381018710405651898072419680038625628403496847878874630005198585018290768191523976457263007140359513843497547268641482458809531359561789398938836874997259)\n</code></pre><p>如代码所示，这个表达式可以用于一直求下一个满足要求的数子，也可以认为是求第无限个满足要求的数字。这样的写法也与上面的例子的类似的道理，要用的时候再计算，要多少算多少。避免一次性算太多而带来的在时间上的延迟和内存上的紧张。</p>\n<h1 id=\"yield-的暂停\"><a href=\"#yield-的暂停\" class=\"headerlink\" title=\"yield 的暂停\"></a>yield 的暂停</h1><p>尽管在 yield 的帮助下可以产生近似无限长的列表，但这也并不是说生成器可以一直下去: 在有些情况下，我们还是希望 yield 能在某个条件下停下。而如果在生成器函数中使用了 <code>return</code>，那么 <code>return</code> 即意味这暂停。</p>\n<p>例如，我们在每次做一次数学测试，一直生成随机数，直至满足某个条件为止。</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">In</span> [81]: def random_test(select, start, end):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         t = random.randint(start, end)\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         <span class=\"hljs-keyword\">if</span> select(t):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:             return\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         <span class=\"hljs-keyword\">else</span>:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:             yield t\n\n<span class=\"hljs-keyword\">In</span> [82]: r = random_test(lambda x : x &lt; 100, 0, 1000)\n\n<span class=\"hljs-keyword\">In</span> [83]: <span class=\"hljs-keyword\">for</span> i, item <span class=\"hljs-keyword\">in</span> enumerate(r):\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     <span class=\"hljs-builtin-name\">print</span>(i, item)\n</code></pre>\n<p>只要不满足 select 条件，这个测试也会一直进行下去，无论是进行多少次，不管是 100 次，还是 1000 次。</p>\n<h2 id=\"return-的在生成器中的含义\"><a href=\"#return-的在生成器中的含义\" class=\"headerlink\" title=\"return 的在生成器中的含义\"></a><code>return</code> 的在生成器中的含义</h2><p><code>return</code> 在生成器中表达的含义就是”一切已经结束了，没有更有趣的元素要返回了”</p>\n<p>基于这个含义，如果在 <code>return</code> 后跟上一个返回值的话，那么这个返回值是不会被返回的。</p>\n\n    <pre><code class=\"lang-python\">In [<span class=\"hljs-number\">84</span>]: <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">return_test</span><span class=\"hljs-params\">()</span></span>:\n   ....:     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Will I be returned?\"</span>\n   ....:     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"I know I will never be returned\"</span>\n\nIn [<span class=\"hljs-number\">85</span>]: r = return_test()\n\nIn [<span class=\"hljs-number\">86</span>]: <span class=\"hljs-keyword\">next</span>(r)\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\n&lt;ipython-input-<span class=\"hljs-number\">86</span>-0b5056469c9c&gt; <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">module</span>&gt;()</span>\n----&gt; <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">next</span>(r)\n\n<span class=\"hljs-symbol\">StopIteration:</span> Will I be returned?\n</code></pre>\n<p>由此可见，执行 <code>return</code> 的时候，生成器就会停止，抛出 <code>StopIteration</code> 表示停止，不会再返回任何返回值。</p>\n<h2 id=\"return-等于-StopIteration\"><a href=\"#return-等于-StopIteration\" class=\"headerlink\" title=\"return 等于 StopIteration ?\"></a><code>return</code> 等于 <code>StopIteration</code> ?</h2><p>既然在上例中，执行 <code>return</code> 就会抛出 <code>StopIteration</code> 异常，那么在生成器函数中，是不是就意味着，<code>StopIteration</code> 是由 <code>return</code> 抛出的呢?</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">In</span> [87]: def catch_stop():\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     try:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         return\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:     except:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>:         yield <span class=\"hljs-string\">\"I catch it\"</span>\n\n<span class=\"hljs-keyword\">In</span> [88]: c = catch_stop()\n\n<span class=\"hljs-keyword\">In</span> [89]: next(c)\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\n&lt;ipython-input-89-73b012f9653f&gt; <span class=\"hljs-keyword\">in</span> &lt;module&gt;()\n----&gt; 1 next(c)\n\nStopIteration:\n</code></pre>\n<p>由代码可见，<code>StopIteration</code> 并没有被捕获，这说明 <code>StopIteration</code> 是在另一个地方抛出的。而至于是在哪里抛出的，目前据我了解，这可能涉及到 Python 底层解释器的实现，我尚不十分了解。</p>\n<h1 id=\"关于生成器函数的实现\"><a href=\"#关于生成器函数的实现\" class=\"headerlink\" title=\"关于生成器函数的实现\"></a>关于生成器函数的实现</h1><p>生成器函数的实现一个重要点就是它保存了每次运行时的环境信息以及下一次的起点。对于普通函数，每一次运行的起点无疑都是从函数的最开头。而对于生成器函数，除了第一次运行的起点是在函数最开头， 每一次运行的起点都是上一次运行结束的终点。</p>\n<p>另外虽然生成器函数保存了环境信息，但这并不说它保存了环境中每个变量的值。</p>\n\n    <pre><code class=\"lang-python\">n [105]: N = 0\n\n<span class=\"hljs-keyword\">In</span> [106]: def test_sum():\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>.:     i = 0\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>.:     <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>.:         yield N + i\n   <span class=\"hljs-built_in\">..</span><span class=\"hljs-built_in\">..</span>.:         i += 1\n\n<span class=\"hljs-keyword\">In</span> [107]: t = test_sum()\n\n<span class=\"hljs-keyword\">In</span> [108]: next(t)\nOut[108]: 0\n\n<span class=\"hljs-keyword\">In</span> [109]: next(t)\nOut[109]: 1\n\n<span class=\"hljs-keyword\">In</span> [110]: N = 100\n\n<span class=\"hljs-keyword\">In</span> [111]: next(t)\nOut[111]: 102\n</code></pre>\n<p>由代码可见，生成器函数保存了环境变量中 <code>N</code> 的存在，但并没有在产生生成器时就将 <code>N</code> 的值定了下来，而仍是每次运行 <code>next</code> 时对其重新求值。</p>\n<h2 id=\"一些猜测\"><a href=\"#一些猜测\" class=\"headerlink\" title=\"一些猜测\"></a>一些猜测</h2><p>联想到 SICP 中对 stream 的实现，那么 Python 可能也有类似的做法，即将一个元素包装在函数里。<br>假如不做延时计算:</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">In</span> [<span class=\"hljs-number\">113</span>]: [<span class=\"hljs-string\">\"how long will it be?\"</span>, time.<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>), time.<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">2</span>)]\nOut[<span class=\"hljs-number\">113</span>]: [<span class=\"hljs-string\">'how long will it be?'</span>, None, None] <span class=\"hljs-meta\"># 3 seconds</span>\n</code></pre>\n<p>这个输出将在 3 秒后输出，但如果讲每个元素包装在函数里:</p>\n\n    <pre><code class=\"lang-python\">In [<span class=\"hljs-number\">114</span>]: lst = [lambd<span class=\"hljs-variable\">a:</span> <span class=\"hljs-string\">\"how long will it be?\"</span>,lambd<span class=\"hljs-variable\">a:</span> time.<span class=\"hljs-keyword\">sleep</span>(<span class=\"hljs-number\">1</span>),lambd<span class=\"hljs-variable\">a:</span> ti\n   .....: <span class=\"hljs-keyword\">me</span>.<span class=\"hljs-keyword\">sleep</span>(<span class=\"hljs-number\">2</span>)]\n\nIn [<span class=\"hljs-number\">115</span>]: <span class=\"hljs-keyword\">for</span> item in <span class=\"hljs-keyword\">ls</span><span class=\"hljs-variable\">t:</span>\n   .....:     <span class=\"hljs-keyword\">print</span>(item())\nhow long will it <span class=\"hljs-keyword\">be</span>?\nNone # <span class=\"hljs-number\">1</span> second\nNone # <span class=\"hljs-number\">2</span> seconds\n</code></pre>\n<p>通过这个方法，每个元素也是在调用是才会被求值，因此我猜测 Python 在实现上可能有类似的做法。但具体是怎么做的，这是一个我接下来需要研究的话题。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>如果对 <code>yield</code> 想要更多的了解，建议查看 <a href=\"https://www.python.org/dev/peps/pep-0255/\" target=\"_blank\" rel=\"external\">PEP 255 – Simple Generators</a>, 其中更进一步的探讨了为什么要引入新的关键字 <code>yield</code>，而不是将其设置为一个内建函数，以及为什么不引入一个新的关键字代替 <code>def</code> 来更清楚地表示某个函数是生成器函数等等。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.python.org/dev/peps/pep-0255/\" target=\"_blank\" rel=\"external\">PEP 255 – Simple Generators</a></li>\n<li><a href=\"https://swizec.com/blog/python-and-lazy-evaluation/swizec/5148\" target=\"_blank\" rel=\"external\">Python and lazy evaluation</a></li>\n</ol>\n","categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"},{"name":"SICP","path":"api/tags/SICP.json"}]}