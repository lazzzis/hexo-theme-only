{"title":"node-thunkify 的实现及源码阅读","slug":"source-code-of-thunkify","date":"2017-06-29T07:52:32.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<p>最近看了些项目的源码，其中就包括 <code>thunkify</code>。虽然 <code>thunkify</code> 代码简单，很快就读完了，不过看看项目的测试文件和提交历史，也还是能看出很多事物的。这次阅读的代码是当前最新版本，commit 编号 <a href=\"https://github.com/tj/node-thunkify/tree/0bd83e29df1bb0653230724f072cff96b0ab684e\" target=\"_blank\" rel=\"external\">0bd83e</a>。</p>\n<h1 id=\"功能陈述\"><a href=\"#功能陈述\" class=\"headerlink\" title=\"功能陈述\"></a>功能陈述</h1><p>将一个函数转换为一个为 Thunk 函数，这个函数被调用后会返回一个以回调函数为参数的函数。可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/generator-async#Thunk-函数\" target=\"_blank\" rel=\"external\">Thunk 函数</a>。</p>\n<h1 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h1><p>因为需求比较简单，所以我自己先实现了一下，然后比较与官方仓库的差异，可以发现一些源码的特点。</p>\n<p>我自己的实现:</p>\n\n    <pre><code class=\"lang-js\">module.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(fn)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(callback)</span> </span>{\n      fn(...args, callback)\n    }\n  }\n}\n</code></pre>\n<h2 id=\"从测试看问题\"><a href=\"#从测试看问题\" class=\"headerlink\" title=\"从测试看问题\"></a>从测试看问题</h2><p>源码有 test 文件，可以将源码的测试文件 clone 到本地后测试。将上面的代码测试后可以发现 3 个测试未通过:</p>\n<ol>\n<li>thunkify(fn) should maintain the receiver</li>\n<li>thunkify(fn) should catch errors</li>\n<li>thunkify(fn) should ignore multiple callbacks</li>\n</ol>\n<h3 id=\"maintain-the-receiver\"><a href=\"#maintain-the-receiver\" class=\"headerlink\" title=\"maintain the receiver\"></a>maintain the receiver</h3><p>通过 test 文件代码发现，这里主要涉及到一个关于 <code>this</code> 的问题:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">load</span> <span class=\"hljs-params\">(fn)</span></span> {\n    fn(null, this.name)\n}\n\nvar user = {\n    name: <span class=\"hljs-string\">'tobi'</span>,\n    <span class=\"hljs-built_in\">load</span>: thunkify(<span class=\"hljs-built_in\">load</span>)\n}\n\nuser.<span class=\"hljs-built_in\">load</span>()(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(err, name)</span></span> {\n    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> done(err)\n    <span class=\"hljs-built_in\">assert</span>(name === <span class=\"hljs-string\">'tobi'</span>)\n    done()\n})\n</code></pre>\n<p>原函数 f 可能是某个对象的方法，所以要保证 thunkify 后的函数，称它为 tf, 仍然能正常访问 <code>this</code> ，所以 tf 函数里需要能引用到原函数 f 里 <code>this</code> 的值，<code>thunkify</code> 源码中用 <code>ctx</code> 变量对其表示原函数 f 的 <code>this</code>：</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> ctx = <span class=\"hljs-keyword\">this</span>; <span class=\"hljs-comment\">// line 27</span>\nfn.apply(ctx, args); <span class=\"hljs-comment\">// line 43</span>\n</code></pre>\n<h3 id=\"catch-errors\"><a href=\"#catch-errors\" class=\"headerlink\" title=\"catch errors\"></a>catch errors</h3><p>尽管原函数 f 是需要一个回调函数做参数，理论上这个回调函数应该能捕捉异常了，但有些时候，这个回调函数可能没有正常 catch，例如测试文件中的样例:</p>\n\n    <pre><code class=\"lang-js\">// fn 作为回调函数却没有捕捉这个异常\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">load</span> <span class=\"hljs-params\">(fn)</span></span> {\n    throw new Error(<span class=\"hljs-string\">'boom'</span>)\n}\n\n<span class=\"hljs-built_in\">load</span> = thunkify(<span class=\"hljs-built_in\">load</span>)\n\n<span class=\"hljs-built_in\">load</span>()(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(err)</span></span> {\n    <span class=\"hljs-built_in\">assert</span>(err)\n    <span class=\"hljs-built_in\">assert</span>(err.message === <span class=\"hljs-string\">'boom'</span>)\n    done()\n})\n</code></pre>\n<p>而 thunkify 则 “帮” 其捕捉了。当发现原函数 f 抛出异常时，源码中自动用用户传进的回调函数捕捉了。</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-comment\">// line 42 - 47</span>\n<span class=\"hljs-comment\">// done 代表用户传进的回调函数</span>\n<span class=\"hljs-selector-tag\">try</span> {\n  <span class=\"hljs-selector-tag\">fn</span><span class=\"hljs-selector-class\">.apply</span>(ctx, args);\n} <span class=\"hljs-selector-tag\">catch</span> (err) {\n  <span class=\"hljs-selector-tag\">done</span>(err);\n}\n</code></pre>\n<h3 id=\"ignore-multiple-callbacks\"><a href=\"#ignore-multiple-callbacks\" class=\"headerlink\" title=\"ignore multiple callbacks\"></a>ignore multiple callbacks</h3><p>理论上讲，一个回调函数 callback 只能被调用一次，但在实际情况中，仍然会存在被调用多次的意外情况，例如测试文件中的例子：</p>\n\n    <pre><code class=\"lang-js\">function <span class=\"hljs-keyword\">load</span> (<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span>) {\n    <span class=\"hljs-keyword\">fn</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">null</span>, <span class=\"hljs-number\">1</span>)</span>\n    <span class=\"hljs-keyword\">fn</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">null</span>, <span class=\"hljs-number\">2</span>)</span>\n    <span class=\"hljs-keyword\">fn</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">null</span>, <span class=\"hljs-number\">3</span>)</span>\n}\n\n<span class=\"hljs-title\">load</span> = thunkify<span class=\"hljs-params\">(<span class=\"hljs-keyword\">load</span>)</span>\n\n<span class=\"hljs-keyword\">load</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(done)</span>\n</span></code></pre>\n<p>为了确保回调函数 callback 只被调用了一次，<code>thunkify</code> 对回调函数进行了一次封装：</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-comment\">// line 34 - 40</span>\n<span class=\"hljs-keyword\">var</span> called;\n\nargs.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">if</span> (called) <span class=\"hljs-keyword\">return</span>;\n    called = <span class=\"hljs-literal\">true</span>;\n    done.apply(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-built_in\">arguments</span>);\n});\n</code></pre>\n<p><code>called</code> 作为一个 flag，第一次调用时，if 语句会把 called 当作否定值，所以 <code>return</code> 不会被执行。但从第二次开始，<code>called</code> 都会变成 <code>true</code>，所以 <code>return</code> 都会执行，确保了回调函数 callback 只会被调用一次。</p>\n<p>这里需要注意一下 <code>args</code> 这个变量，它每次都会 <code>push</code> 一下，因为 <code>thunkify</code> 后的函数 tf 可能被引用调用多次:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-symbol\">function</span> <span class=\"hljs-meta\">fn</span> (done) {\n  done(null, Date.now())\n}\n\n<span class=\"hljs-symbol\">let</span> tf = thunkify(<span class=\"hljs-meta\">fn</span>)()\n\n<span class=\"hljs-symbol\">let</span> <span class=\"hljs-built_in\">c1</span>, <span class=\"hljs-built_in\">c2</span>, <span class=\"hljs-built_in\">c3</span>\n<span class=\"hljs-symbol\">c1</span> = <span class=\"hljs-built_in\">c2</span> = <span class=\"hljs-built_in\">c3</span> = (err, value) =&gt; console.log(value)\n\n<span class=\"hljs-symbol\">tf</span>(<span class=\"hljs-built_in\">c1</span>)\n<span class=\"hljs-symbol\">tf</span>(<span class=\"hljs-built_in\">c2</span>)\n<span class=\"hljs-symbol\">tf</span>(<span class=\"hljs-built_in\">c3</span>)\n</code></pre>\n<p>这个程序最后只会输出一次值。因为根据闭包规则，第二次调用 tf 开始，回调函数就被 <code>push</code> 进 <code>args</code> 里了。当第三次调用 tf 时，此时的 args 等价为 <code>[c1, c2, c3]</code>，根据源码， <code>tf(c3)</code> 相当于调用 <code>tf.apply(ctx, [c1, c2, c3])</code>。所以此时真正执行的回调是 <code>c1</code>，如前文所说，这个 <code>c1</code> 是被源码封装过的，里面的内容只会被执行一次。</p>\n<h3 id=\"自己的实现（改进后）\"><a href=\"#自己的实现（改进后）\" class=\"headerlink\" title=\"自己的实现（改进后）\"></a>自己的实现（改进后）</h3><p>结合 ES6，自己在解决上述问题后又实现了一遍，功能上没有改变，全是增加鲁棒性</p>\n\n    <pre><code class=\"lang-js\">module.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(fn)</span> </span>{\n  assert(<span class=\"hljs-string\">'function'</span> === <span class=\"hljs-keyword\">typeof</span> fn, <span class=\"hljs-string\">'function required'</span>)\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> </span>{\n    <span class=\"hljs-keyword\">const</span> ctx = <span class=\"hljs-keyword\">this</span> <span class=\"hljs-comment\">// fix test 'should maintain the receiver'</span>\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(callback)</span> </span>{\n      <span class=\"hljs-keyword\">const</span> refinedCallback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(callback)</span> </span>{\n        let first = <span class=\"hljs-literal\">true</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> </span>{\n          <span class=\"hljs-keyword\">if</span> (!first) <span class=\"hljs-keyword\">return</span>\n          first = <span class=\"hljs-literal\">false</span>\n          callback(...args)\n        }\n      }\n\n      args.push(refinedCallback(callback))\n\n      <span class=\"hljs-keyword\">try</span> {\n        fn.call(ctx, ...args)\n      } <span class=\"hljs-keyword\">catch</span> (err) {\n        callback(err)\n      }\n    }\n  }\n}\n</code></pre>\n<h2 id=\"从-Commit-看改进\"><a href=\"#从-Commit-看改进\" class=\"headerlink\" title=\"从 Commit 看改进\"></a>从 Commit 看改进</h2><p>查看各个 commit，以及以前的代码，可以发现一些有趣的事。</p>\n<h3 id=\"crankshaft\"><a href=\"#crankshaft\" class=\"headerlink\" title=\"crankshaft\"></a>crankshaft</h3><p>在 <a href=\"https://github.com/tj/node-thunkify/commit/d537460eb23e3d556c4f726eb04bef189dd3994f\" target=\"_blank\" rel=\"external\">d53746</a> 这个 commit 中，提交者改变了 arguments 变成了数组的方式，从简单的 slice 方法，变成了声明一个数组然后一一赋值的方法。</p>\n<p>第一次看到 <code>crankshaft</code> 还不知道是什么，后来才知道是指代 Chrome 的一个引擎。<a href=\"https://github.com/tj/node-thunkify/pull/12\" target=\"_blank\" rel=\"external\">Pull request #12</a> 有提到这个优化，虽然我还是觉得这个优化在某种程度牺牲了部分可读性。</p>\n<h3 id=\"remove-memoization\"><a href=\"#remove-memoization\" class=\"headerlink\" title=\"remove memoization\"></a>remove memoization</h3><p>参考 <a href=\"https://github.com/tj/node-thunkify/commit/30f25adebf79f4793fd5c8b6f873d5e093dfaf6d\" target=\"_blank\" rel=\"external\">30f25a</a> 移除了一个记忆化操作。</p>\n<p>在这个版本之前的代码，如果执行下面的程序，会发现这三次执行都输出同样的结果，这多多少少有点反直觉，所以 commit 上 tj 也说 <code>promises have different expectations</code>。</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\">done</span>) </span>{\n  done(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-built_in\">Date</span>.now())\n}\n\n<span class=\"hljs-keyword\">let</span> dtn = thunkify(fn)()\n\ndtn(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, value</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(value))\ndtn(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, value</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(value))\ndtn(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, value</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(value))\n</code></pre>\n<p>所以这个改进后，执行上述程序只会输出一次结果。</p>\n<h3 id=\"add-assert-fn\"><a href=\"#add-assert-fn\" class=\"headerlink\" title=\"add assert(fn)\"></a>add assert(fn)</h3><p>在 <a href=\"https://github.com/tj/node-thunkify/commit/05abda9cba45b8669caebbeab4fbe5f4a666336b\" target=\"_blank\" rel=\"external\">05abda</a> 处增加了一个 assert 调用避免被 thunkify 的参数不是函数 – 一个提高函数鲁棒性的功能。</p>\n<h3 id=\"remove-support-for-eager-execution\"><a href=\"#remove-support-for-eager-execution\" class=\"headerlink\" title=\"remove support for eager execution\"></a>remove support for eager execution</h3><p><a href=\"https://github.com/tj/node-thunkify/commit/a504b918a93d04aaa62f467ae7213a25f47d0f69\" target=\"_blank\" rel=\"external\">a504b9</a> 算一次比较大的改进，发现这个 commit 大大缩减了代码。不过这次删去了避免回调函数被多次执行的代码，也就是对回调函数的封装。在这之后的几个 commit 里，维护者又把这一层封装添加了回去。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在没有看过 <code>thunkify</code> 源码的情况下，这个功能的实现并不算难。但 <code>thunkify</code> 代码比在本文开始我自己写的代码更优秀的地方就在于代码的鲁棒性，这一点从测试文件和 commit 日志中可见一斑，确实考虑了生产环境中可能出现的众多复杂情况，更适合日常使用。同时，阅读 <code>thunkify</code> 源码的目的也并不限于代码的实现，更多的是学习维护和增加代码的鲁棒性。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/generator-async\" target=\"_blank\" rel=\"external\">Generator 函数的异步应用</a></li>\n<li><a href=\"https://blog.daraw.cn/2016/11/11/notes-about-node-thunkify/\" target=\"_blank\" rel=\"external\">node-thunkify源码阅读笔记</a></li>\n</ol>\n","categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]}