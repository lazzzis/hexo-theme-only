{"title":"UVa1395 - Slim Span","slug":"uva1395","date":"2016-01-25T06:05:41.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>首先有一点是可以确定的：对于任何一连通图，必有一生成树（简直废话）。<br>对于这一题，关键的问题是确定最大与最小。对于这种寻找两个相关变量的题，其实一般可以先试着确定一个，然后再去寻找另一个。<br>比如在这题中，可以迭代每一个边 L，同时把这条边 L 当做最小的边，用比它大的边去试着连同一幅图，知道找到边 R， 使得加上这条边 R 后刚好可以凑成一幅联通图。<br>因此，从上述思路可以看出，排序是必不可少了。所有排序是第一步。<br>排序好后进行遍历 L，建立 N （顶点数） 个并查集 S，每加入一条边就将该边的端点对应的并查集合并（前提是两个端点对应不同的并查集）。<br>直到刚好加入边 R 后，并查集只剩一个，且大小刚好与顶点数相等。此时对于 L 来说，R － L 极为其 “苗条度”。<br>因此对所有求得的“苗条度”求一个最小值即可。如果连一个“苗条度”都没有，那结果自然就是找不到合适的答案了。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1>\n    <pre><code class=\"lang-cpp\"><span class=\"hljs-comment\">/*\n * Run Time : 0.033s\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;algorithm&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Node</span>{</span>\n    <span class=\"hljs-keyword\">int</span> first, second;\n    <span class=\"hljs-keyword\">int</span> len;\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">cmp</span><span class=\"hljs-params\">(Node a, Node b)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> a.len &lt; b.len;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> INF = <span class=\"hljs-number\">1000000</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> MAXN = <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">50</span>;\n<span class=\"hljs-keyword\">int</span> N, M;\n<span class=\"hljs-built_in\">vector</span>&lt;Node&gt; nodes;\n<span class=\"hljs-keyword\">int</span> size[MAXN], root[MAXN];\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">int</span> a, b, k;\n    nodes.clear();\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; M; ++ i) {\n        <span class=\"hljs-built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;\n        Node n;\n        n.first = a; n.second = b; n.len = k;\n        nodes.push_back(n);\n    }\n}\n\n<span class=\"hljs-keyword\">int</span> ans;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root[n] == n) {\n        <span class=\"hljs-keyword\">return</span> n;\n    }\n    <span class=\"hljs-keyword\">return</span> root[n] = Find(root[n]);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span> </span>{\n    sort(nodes.begin(), nodes.end(), cmp);\n    ans = INF;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j; i &lt; M; ++ i) {\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">1</span>; j &lt;= N; ++ j) {\n            size[j] = <span class=\"hljs-number\">1</span>;\n            root[j] = j;\n        }\n        <span class=\"hljs-keyword\">for</span> (j = i; j &lt; M; ++ j) {\n            <span class=\"hljs-keyword\">int</span> ra = Find(nodes[j].first);\n            <span class=\"hljs-keyword\">int</span> rb = Find(nodes[j].second);\n            <span class=\"hljs-keyword\">if</span> (ra != rb) {\n                root[rb] = ra;\n                size[ra] += size[rb];\n            }\n            <span class=\"hljs-keyword\">if</span> (size[Find(<span class=\"hljs-number\">1</span>)] == N) {\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (size[Find(<span class=\"hljs-number\">1</span>)] == N) {\n            ans = min(nodes[j].len - nodes[i].len, ans);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (size[Find(<span class=\"hljs-number\">1</span>)] &lt; N) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    ios::sync_with_stdio(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-built_in\">cin</span>.tie(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-built_in\">cin</span> &gt;&gt; N &gt;&gt; M &amp;&amp; (N + M)) {\n        read();\n        work();\n        <span class=\"hljs-built_in\">cout</span> &lt;&lt; (ans == INF ? <span class=\"hljs-number\">-1</span> : ans) &lt;&lt; <span class=\"hljs-built_in\">endl</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>最近没怎么练习，在做这题时犯了一个低级错误。刚开始使用了一个 set （集合）代替并查集。当 set 大小为 N 时，即可计算“苗条度”<br>这种想法当然是<strong>错误</strong>的！！！很明贤，顶点数达到要求了，但并不一定代表图已经连通！</p>\n","categories":[{"name":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","path":"api/tags/ACM.json"},{"name":"UVaOJ","path":"api/tags/UVaOJ.json"}]}