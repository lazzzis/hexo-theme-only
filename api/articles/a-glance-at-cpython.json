{"title":"初看 CPython","slug":"a-glance-at-cpython","date":"2017-01-04T12:24:13.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<h1 id=\"什么是-CPython\"><a href=\"#什么是-CPython\" class=\"headerlink\" title=\"什么是 CPython\"></a>什么是 CPython</h1><p>简单的说, <code>CPython</code> 是 Python 解释器的一个实现。换句话说，Python 解释器是由 C 写的，然后由 GCC 之类的编译器编译而成的可执行文件。除了 CPython，还有 <a href=\"http://pypy.org/\" target=\"_blank\" rel=\"external\">PyPy</a>(用 Python 实现的 Python 解释器)，<a href=\"http://www.skulpt.org/\" target=\"_blank\" rel=\"external\">Skulpt</a>(用 JavaScript 实现的 Python 解释器) 等等。如果你不知道你用的是哪一个，那么你一定用的就是 CPython。因为 CPython 是 Python 官方的解释器实现，其它均属于第三方实现。</p>\n<h1 id=\"从源码到运行\"><a href=\"#从源码到运行\" class=\"headerlink\" title=\"从源码到运行\"></a>从源码到运行</h1><p>对于从 Python 源码到解释器执行它们的这个过程，我把它分为两大步 —— 编译(Compiling) 与 解释(Interpreting)。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>尽管 Python 一门典型的解释型语言 —— 与编译型语言(C, C++) 相对，但 Python 的运行确实涉及到了编译的部分。</p>\n<p>编译在这里的主要功能是将源代码转换为字节码，包括编译了原理中两个关键步骤，词法分析与语法分析，即 lexing, parsing, 也包含了语法检查，即 <code>SyntaxError</code> 可能在这个过程中抛出。</p>\n<p>而由 Python 编译而来的字节码似于如下:</p>\n<pre><code>  1           0 LOAD_NAME                0 (print)\n              2 LOAD_CONST               0 (&#39;hello world&#39;)\n              4 CALL_FUNCTION            1\n              6 POP_TOP\n              8 LOAD_CONST               1 (None)\n             10 RETURN_VALUE\n</code></pre><p>关于字节码的内容，后面将进一步讨论</p>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>在这一步，Python 解释器对编译生成的字节码进行解释。且在实际过程中，编译所做的只占很少一部分，也就是说：解释的部分远大于编译的部分 —— 这也是为什么 Python 仍被成为解释型语言的重要原因之一。</p>\n<p>因为 Python 解释器对字节码而非源码进行解释，因此 Python 解释器也会被称为 Python 虚拟机(Python Virtual Machine / PVM)。特别需要指出，尽管 Python 虚拟机与 Java 虚拟机都被称为虚拟机，但两者内部之间仍有较大差别(可以参考<a href=\"https://www.zhihu.com/question/23727114\" target=\"_blank\" rel=\"external\">link</a>)。</p>\n<h2 id=\"字节码的意义\"><a href=\"#字节码的意义\" class=\"headerlink\" title=\"字节码的意义\"></a>字节码的意义</h2><p><strong>为什么不直接解释源码？</strong><br>实际上，直接解释源码在理论上当然是可行的。但这样做也有一些缺点。<br>举个例子:</p>\n<pre><code>def test(x, y):\n    if x &lt; y:\n        return 1\n    elif x == y:\n        return 2\n    return 3\n</code></pre><p>如果直接解释源码，那么你每次执行 test 函数都要对函数体重新分析，也就要依次分析出 <code>if</code> 语块，<code>if</code> 条件部分。等结构分析好了，之后，才能对 x, y 取值进行比较。</p>\n<p>但事实上，代码一旦写好，结构不会再变，会变的只是变量的取值。那么可以先对其编译，编译好后再解释就不需要每次重新分析结构，而是可以直接就对 x, y 进行取值比较。从这个角度讲，编译成字节码提高了解释器的效率。</p>\n<p>其次，字节码的存在类似于汇编的存在。汇编介于 C 语言与硬件之间，作为抽象的中间层用于降低开发的复杂度。Python 中的字节码也是如此。</p>\n<h1 id=\"字节码指令集\"><a href=\"#字节码指令集\" class=\"headerlink\" title=\"字节码指令集\"></a>字节码指令集</h1><h2 id=\"查看字节码\"><a href=\"#查看字节码\" class=\"headerlink\" title=\"查看字节码\"></a>查看字节码</h2><p>Python 提高 <code>dis</code> 模块供用户查看由 Python 源码编译而成的字节码。</p>\n<p>假设下列代码是 <code>test.py</code> 中的全部内容:</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-attr\">x</span> = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-attr\">y</span> = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-attr\">z</span> = x + y\n</code></pre>\n<p>在终端中输入</p>\n\n    <pre><code class=\"lang-bash\">python -<span class=\"hljs-keyword\">m</span> <span class=\"hljs-keyword\">dis</span> <span class=\"hljs-keyword\">test</span>.py\n</code></pre>\n<p>可以看到输出的字节码:</p>\n<pre><code>  1           0 LOAD_CONST               0 (1)\n              3 STORE_NAME               0 (x)\n\n  2           6 LOAD_CONST               1 (2)\n              9 STORE_NAME               1 (y)\n\n  3          12 LOAD_NAME                0 (x)\n             15 LOAD_NAME                1 (y)\n             18 BINARY_ADD\n             19 STORE_NAME               2 (z)\n             22 LOAD_CONST               2 (None)\n             25 RETURN_VALUE\n</code></pre><p>其中每一列代表的含义为:</p>\n<pre><code>行号            字节码偏移量     字节码指令        指令参数          对于参数的相关说明\n   1             0            LOAD_CONST        0               (1)\n</code></pre><h2 id=\"解释字节码\"><a href=\"#解释字节码\" class=\"headerlink\" title=\"解释字节码\"></a>解释字节码</h2><p>Python 解释器对字节码指令进行解释，同时对 <strong>栈</strong> (Stack)进行操作 —- Python 虚拟机属于 <strong>栈机器</strong> (Stack machine)。值的存取都是基于栈来实现的。类似下图:<br><img src=\"https://markfaction.files.wordpress.com/2012/07/stackadd.png\" alt=\"7 + 20 的实现过程: 将读到的7 与 20存放与栈中，然后取出相加, 并将结果放入栈中\"></p>\n<p><strong>栈机器</strong> 优于 <strong>寄存器机器</strong>(Register Virtual Machine) 的一个地方是不需要对地址的存取，数据的读取通过 POP 和 PUSH 的到，而非通过一个寄存器地址，操作上相对简单。</p>\n<h3 id=\"字节码指令集有哪些\"><a href=\"#字节码指令集有哪些\" class=\"headerlink\" title=\"字节码指令集有哪些\"></a>字节码指令集有哪些</h3><p>所有的指令码可以在这个网页中看到: <a href=\"https://hg.python.org/cpython/file/v2.7.8/Include/opcode.h\" target=\"_blank\" rel=\"external\">https://hg.python.org/cpython/file/v2.7.8/Include/opcode.h</a>。这里以网上资料比较多的 2.7.8 为例。从 0 – 147 共148个指令，每个指令都对应特定的功能。任何 Python 源码编译后形成的字节码都可以在这其中找到。</p>\n<h3 id=\"字节码从哪里被执行\"><a href=\"#字节码从哪里被执行\" class=\"headerlink\" title=\"字节码从哪里被执行\"></a>字节码从哪里被执行</h3><p>仍以 2.7.8 为例，查看 CPython 工程的 Python/ceval.c 文件: <a href=\"https://hg.python.org/cpython/file/v2.7.8/Python/ceval.c\" target=\"_blank\" rel=\"external\">https://hg.python.org/cpython/file/v2.7.8/Python/ceval.c</a>。<br>第 964 行处有一个 <code>for (;;)</code> 语句块，负责不断读入每一条指令并执行。</p>\n<p>继续往下看，第 1112 行有一个“庞大”的 <code>switch</code> 语块。负责检查每一条指令具体是哪一条指令，然后采取对应的操作。</p>\n<p>以 1148 行的 <code>POP_TOP</code> 为例:</p>\n\n    <pre><code class=\"lang-c\">case POP_TOP:\n    v = POP()<span class=\"hljs-comment\">;</span>\n    Py_DECREF(v)<span class=\"hljs-comment\">;</span>\n    goto fast_next_opcode<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>对应的操作可描述为: 取并弹出栈顶的数据，对这个数据的计数器减一，执行下一条指令。</p>\n<p>CPython 便是以此循环，直到因为用户终止等原因才停止运行。</p>\n<h1 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h1><p>目前这是一篇极其浅显的对 CPython 的描述。我最近正在学习和研究 CPython 的源码。如果有新的理解，我会继续更新。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://youtu.be/HVUTjQzESeo\" target=\"_blank\" rel=\"external\">Allison Kaptur - Bytes in the Machine: Inside the CPython interpreter - PyCon 2015</a></li>\n<li><a href=\"https://youtu.be/LhadeL7_EIU?list=PLzV58Zm8FuBL6OAv1Yu6AwXZrnsFbbR0S\" target=\"_blank\" rel=\"external\">CPython internals - Interpreter and source code overview</a></li>\n<li><a href=\"https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/\" target=\"_blank\" rel=\"external\">Stack based vs Register based Virtual Machine Architecture, and the Dalvik VM</a></li>\n<li><a href=\"http://stackoverflow.com/questions/441824/java-virtual-machine-vs-python-interpreter-parlance\" target=\"_blank\" rel=\"external\">Java “Virtual Machine” vs. Python “Interpreter” parlance?</a></li>\n</ol>\n","categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]}