{"title":"Java 中 wait 与 notify 的简单操作","slug":"java-wait-notify-usage","date":"2016-02-15T14:05:51.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<p>在我知道wait() 与 notify() 以前，我常常用一种看似很 low 的方式控制线程同步</p>\n\n    <pre><code class=\"lang-java\"><span class=\"hljs-keyword\">while</span>(condition) {\n  <span class=\"hljs-keyword\">return</span> ;\n}\n</code></pre>\n<p>实际上这个线程是一直在运行的，并没有操作系统概念中的阻塞（Block）。而要实现阻塞（Block）则要借助 Java 线程中的 wait() 操作 与 notify() 操作。</p>\n<h1 id=\"相对简单的例子\"><a href=\"#相对简单的例子\" class=\"headerlink\" title=\"相对简单的例子\"></a>相对简单的例子</h1><p>wait() 操作与 notify() 操作必须在临界区内进行。而 synchronized 需要一个对象用作锁，以区分各个不同的临界区。比如临界区 A 中进行了 wait() 操作，在也必须在临界区A 中进行 notify() 操作。</p>\n<p>现看一个例子：</p>\n\n    <pre><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        TestThread testThread = <span class=\"hljs-keyword\">new</span> TestThread();\n        testThread.start();\n        <span class=\"hljs-keyword\">synchronized</span> (testThread) {\n            System.out.println(<span class=\"hljs-string\">\"Before wait\"</span>);\n            <span class=\"hljs-keyword\">try</span> {\n                testThread.wait();\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(<span class=\"hljs-string\">\"All completed!\"</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestThread</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) {\n            <span class=\"hljs-keyword\">try</span> {\n                Thread.sleep(<span class=\"hljs-number\">5000</span>);\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(<span class=\"hljs-string\">\"notify() Completed\"</span>);\n            notify();\n        }\n    }\n}\n</code></pre>\n<p>例子中用了两次 <code>synchronized</code> ，但两次对应的参数是相同的，所以这两块代码都属于同一个临界区。当执行 wait 操作时，程序进入阻塞状态，在进行 notify 操作前，不会进行下一步，即不会输出<code>All completed!</code>。当 sleep 完成，即过了 5 秒钟后，触发 notify() 操作，打印<code>notify() Completed</code>。此时程序从阻塞状态进入就绪状态，然后进入运行状态，输出<code>All completed!</code>。</p>\n<p><em>注意点</em>:</p>\n<ol>\n<li>切记 wait 操作和 notify 操作要在同一个临界区中进行。</li>\n<li>在执行 wait 操作时会抛出一个 InterruptedException 的异常，记得捕获。</li>\n</ol>\n<p>输出结果参考：</p>\n\n    <pre><code class=\"lang-java\">Before wait\n<span class=\"hljs-function\"><span class=\"hljs-title\">notify</span><span class=\"hljs-params\">()</span></span> Completed\nAll completed!\n</code></pre>\n<h1 id=\"相对复杂的例子\"><a href=\"#相对复杂的例子\" class=\"headerlink\" title=\"相对复杂的例子\"></a>相对复杂的例子</h1><p>从上面一个例子看出，wait 和 notify 操作实现了进程同步，类似于播放器的暂停(wait)与继续(notify)。只有在 notify 的情况下才能继续 wait 之后的内容，可以保证一些临界值的准确性。</p>\n<p>在操作系统概念中，有一个典型的 <em>消费者与生产者</em> 的模型。在一块区域中，最多存放 5 个 unit 的物品，当区域中的物品少于 5 个时，生产者就会生产 1 个 unit 的物品放在区域内；当区域中的物品大于 0 个时，消费者就会从区域中取走 1 个 unit 的物品。</p>\n<p>如果用 wait 与 notify 模拟的话，那就是要控制好两者的出现时机。</p>\n<p>先看代码：</p>\n\n    <pre><code class=\"lang-java\"><span class=\"hljs-keyword\">import</span> java.util.Date;\n<span class=\"hljs-keyword\">import</span> java.util.Vector;\n<span class=\"hljs-comment\">/**\n* Created by lazzzis on 2/9/16.\n*/</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        Producer producer = <span class=\"hljs-keyword\">new</span> Producer();\n        producer.start();\n        <span class=\"hljs-keyword\">new</span> Consumer(producer).start();\n        <span class=\"hljs-keyword\">try</span> {\n            Thread.sleep(<span class=\"hljs-number\">80</span>);\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.exit(<span class=\"hljs-number\">0</span>);\n    }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Producer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MAXQUEUE = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">private</span> Vector messages = <span class=\"hljs-keyword\">new</span> Vector();\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n                <span class=\"hljs-keyword\">this</span>.putMessage();\n            }\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">putMessage</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>{\n        <span class=\"hljs-keyword\">while</span> (messages.size() == MAXQUEUE) {\n            System.out.println(<span class=\"hljs-string\">\"I\\'m waiting!\"</span>);\n            wait();\n        }\n        messages.addElement(<span class=\"hljs-keyword\">new</span> Date().toString());\n        System.out.println(<span class=\"hljs-string\">\"put message\"</span>);\n        notify();\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> String <span class=\"hljs-title\">getMessage</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>{\n        notify();\n        <span class=\"hljs-keyword\">while</span> (messages.size() == <span class=\"hljs-number\">0</span>) {\n            wait();\n        }\n        String message = (String) messages.firstElement();\n        messages.removeElement(message);\n        <span class=\"hljs-keyword\">return</span> message;\n    }\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Consumer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>{\n    Producer producer;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Consumer</span><span class=\"hljs-params\">(Producer p)</span> </span>{\n        producer = p;\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n                String message = producer.getMessage();\n                System.out.println(<span class=\"hljs-string\">\"Got message: \"</span> + message);\n            }\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p><em>注意点:</em></p>\n<ol>\n<li><code>synchronized</code>对于同一对象的不同方法，算作同样的临界区</li>\n<li>两个方法中 notify 和 wait 的顺序相反，如果相同，极有可能发生两者同时处于wait状态，而导致无法触发 notify 的情况。</li>\n<li>在 getMessage 中触发 notify 会使触发 wait 的 putMessage 继续运行，相当于一旦有物品被取走，就会通知生产者马上生产一个</li>\n<li>在 putMessage 中触发 notify 会使触发 wait 的 getMessage 继续运行，相当于一旦有物品被生产，就会通知消费者马上取走一个。</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"http://www.programcreek.com/2009/02/notify-and-wait-example/\" target=\"_blank\" rel=\"external\">Java Thread: notify() and wait() examples</a></li>\n<li><a href=\"http://stackoverflow.com/questions/886722/how-to-use-wait-and-notify-in-java\" target=\"_blank\" rel=\"external\">How to use wait and notify in Java?</a></li>\n</ol>\n","categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Thread","path":"api/tags/Thread.json"}]}