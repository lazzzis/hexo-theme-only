{"title":"howdoi 源码阅读与分析","slug":"source-code-of-howdoi","date":"2017-03-04T13:49:27.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<p><a href=\"https://github.com/gleitz/howdoi\" target=\"_blank\" rel=\"external\">howdoi</a> – 一款通过命令行帮你从 stackoverflow 中寻找答案的工具，其源代码部分不足 300 行。同时，这份代码被 <a href=\"http://docs.python-guide.org/en/latest/writing/reading/\" target=\"_blank\" rel=\"external\">The Hitchhiker’s Guide to Python!</a> 推荐为适合新手源码阅读的代码。因此，在读完源码后，我分享一下我对这份代码的理解。</p>\n<p>这里采用的版本是 tree 中标号为 <a href=\"https://github.com/gleitz/howdoi/tree/d84afdee603dbe699153e35650d46ddd734337d1\" target=\"_blank\" rel=\"external\">d84afdee60</a> 的那一版</p>\n<h1 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h1><p>简单的概括:</p>\n<blockquote>\n<p>获取搜索关键词 –&gt; 通过爬虫找到 stackoverflow 上的答案(html 格式) –&gt; 对 html 进行解析拿到答案</p>\n</blockquote>\n<p><img src=\"https://s8.postimg.org/nqgt134np/Screen_Shot_2017_03_04_at_22_59_06.png\" alt=\"一副简单的示意图\"></p>\n<h2 id=\"获取关键词\"><a href=\"#获取关键词\" class=\"headerlink\" title=\"获取关键词\"></a>获取关键词</h2><p>其中 <strong>关键词</strong> 必须从终端获取，这一步可以通过 Python 自带的包 <code>argparse</code> 实现。</p>\n<p>在代码的第 153 行，<code>args[&#39;query&#39;] = &#39; &#39;.join(args[&#39;query&#39;]).replace(&#39;?&#39;, &#39;&#39;)</code>， 这里作者将关键词中的问号去掉了。刚开始误以为这个处理是怕将问号放到 url 后，问号后面的字符串会变为 url 中查询的参数，从而没有达到使用者的意图。事实上，我的这个想法是错误的，因为之后的代码中，作者会将查询的字符串转义了。我的第二个猜测认为问号会影响 google 查询的结果，因为 <code>?</code> 符号是 google 搜索的指令之一，比如 搜索 <code>c?lor</code> 和 <code>clor</code> 的结果几乎是完全不同的。</p>\n<h2 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h2><p>而爬虫部分，则使用包 <strong>requests</strong> ，其中 url 采用的是 google 搜索的 url, <code>&#39;https://www.google.com/search?q=site:{0}%20{1}&#39;</code>。其中 0 位对应搜索的目标网站，而 1 位代表搜索的内容。比如 <code>&#39;https://www.google.com/search?q=site:stackoverflow.com%20python%20async&#39;</code> 代表在 stackoverflow 上搜索有关 <code>python async</code> 的内容，相当于你在 google 的搜索框里输入了 <code>site:stackoverflow python async</code>。其中 site 是 google 搜索的一个指令，其它指令还包括 <code>filetype</code> (制定文件类型)等。</p>\n<p>而 1 的位置填的搜索的内容正是命令行中输入的内容。为了安全起见，最好将其转义，如代码中 95 行所示 <code>result = _get_result(SEARCH_URL.format(URL, url_quote(query)))</code>。假如 <code>query = &#39;foo bar&#39;</code>, 那么转义后 <code>query = &#39;foo%20bar&#39;</code>。</p>\n<h2 id=\"解析-html\"><a href=\"#解析-html\" class=\"headerlink\" title=\"解析 html\"></a>解析 html</h2><p>采用的工具是 <code>pyquery</code>，它可以让使用者像使用 <code>jquery</code> 一样解析 html 代码。</p>\n<p>第一次拿到的 html 是 google 搜索的结果，而不是 stackoverflow 的页面，所以要先拿到有答案的 stackoverflow 的页面。函数 <code>_is_question</code> 帮助程序识别超链接是否是 stackoverflow 的链接。</p>\n<p>如果是 stackoverflow 的链接，那么接下来有一个分支 – 第 151, 152 行。</p>\n<ol>\n<li>用户只需要 url。那么就此打住，将 url 返回即可。</li>\n<li>如果用户需要答案。就对这个链接做一次请求，这一次拿到的 html 就是 stackoverflow 有提问和回答的页面了。为了提高拿到的答案的可靠型，在 153 行，<code>page = _get_result(link + &#39;?answertab=votes&#39;)</code> 使得 stackoverflow 页面返回的结果是根据答案的支持数从高到低排序的。</li>\n</ol>\n<p>拿到页面后，再对 html 分析，这里又有一个分支。如果用户只要代码，拿到 <code>pre</code> 标签内或 <code>code</code> 标签内的内容返回，否则把答案的文本全部返回。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>以下几个部分即使删去，也并不也影响程序的主要功能。但加上的话可以很好的改善用户体验。</p>\n<h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p>对应函数 <code>get_proxies</code>。其中作者还为没有用 http 开头的网址加了 http，比如 <code>{&#39;http&#39;: &#39;localhost:1080&#39;}</code> 会转化为 <code>{&#39;http&#39;: &#39;http://localhost:1080&#39;}</code>。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>如果开启缓存而且搜索次数多了，缓存可以很好地改善用户体验。作者的实现采用了 <code>requests_cache</code>。使用也挺简单的，不多说了，可以参考<a href=\"https://github.com/reclosedev/requests-cache\" target=\"_blank\" rel=\"external\">文档</a>。</p>\n<h3 id=\"颜色输出\"><a href=\"#颜色输出\" class=\"headerlink\" title=\"颜色输出\"></a>颜色输出</h3><p>这也是改善用户体验的一个途径。作者采用的是 <a href=\"http://pygments.org/\" target=\"_blank\" rel=\"external\">pygments</a> 。用 pygments 提供的 lexer 对字符串解析并加上颜色。</p>\n<h1 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h1><p>这里讲一些我从这份源码中比较有启发的代码风格</p>\n<h2 id=\"私有函数\"><a href=\"#私有函数\" class=\"headerlink\" title=\"私有函数\"></a>私有函数</h2><p>Python 中并没有严格意义上的 私有函数，一般来讲，名字以但下划线开头的即为 <strong>不推荐调用</strong> 的函数，也可以认为属于私有函数。而观察这个项目以前的代码，可以发现最早并没有私有函数。私有函数的出现起于 <a href=\"https://github.com/gleitz/howdoi/pull/132\" target=\"_blank\" rel=\"external\">Pull Request: PEP 8 conventions #132</a>。个人认为区分私有和公有的区分对于使用者的学习还是有帮助的，尤其是文档不多或者使用者比较着急使用的情况下，使用者可以直接看公有函数。另外，公有函数也警告使用者不要随意调用，因为有些私有函数的随意调用可能会造成一些对项目比较危险的结果。</p>\n<h2 id=\"函数的顺序\"><a href=\"#函数的顺序\" class=\"headerlink\" title=\"函数的顺序\"></a>函数的顺序</h2><p>不知是无意还是有意，函数的顺序根据调用的顺序逆序排列。比如我们从 <code>command_line_runner</code> 看起，这个函数第一个出现的调用是 <code>get_parser</code>，而源码中 <code>command_line_runner</code> 的上一个函数就是 <code>get_parser</code>。继续往下看，则可以看到 <code>_clear_cache</code>, <code>_enable_cache</code>。而这个顺序刚好是你从文件尾往文件头看得顺序。也就是说，每次我看到一个函数调用时，我肯定往上翻就行了，而且越先看到的越先出现，这给阅读源码带来了很大的便利。</p>\n<h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><p>我发现这里的常量包括了作为模板的字符串，如 <code>SEARCH_URL = &#39;https://www.google.com/search?q=site:{0}%20{1}&#39;</code>。仔细想想，我好像以前写常量都是固定的字符串或数字，这种模板型的字符串常量我好像一直没用过。</p>\n<h1 id=\"小细节\"><a href=\"#小细节\" class=\"headerlink\" title=\"小细节\"></a>小细节</h1><p><code>URL = os.getenv(&#39;HOWDOI_URL&#39;) or &#39;stackoverflow.com&#39;</code></p>\n<p>注意这里用的 stackoverflow 地址是 <code>stackoverflow.com</code>  而不是 <code>www.stackoverflow.com</code>。这是有区别的。使用前者搜索，出来的 stackoverflow 相关链接大多是 <code>stackoverflow.com/problems/(\\d+)/</code> 形式，而使用后者，大多出现的是 <code>www.stackoverflow.com/a/(\\d+)/</code> 形式。前者的形式相对后者的形式更容易判断一个链接是不是 stackoverflow 的问题链接。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>howdoi 的点子很好，而且源码确实比较易懂。读完源码之后，建议可以自己试着实现一个类似的或用其它语言复刻一个。毕竟，有些问题是只有开发时才能想到的。</p>\n","categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]}