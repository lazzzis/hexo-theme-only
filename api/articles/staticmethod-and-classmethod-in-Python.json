{"title":"Python @staticmethod 与 @classmethod 的区别分析","slug":"staticmethod-and-classmethod-in-Python","date":"2016-02-03T13:33:09.000Z","updated":"2017-07-30T05:48:51.000Z","comments":true,"excerpt":"","content":"<p>乍一看之下，@staticmethod 与 @classmethod 真的很相似，貌似都可以看作是静态函数，除了后者必须有一个传入参数外就貌似没区别了。但既然加入了，那也一定有开发者的考虑了。</p>\n<h1 id=\"相同点：调用者\"><a href=\"#相同点：调用者\" class=\"headerlink\" title=\"相同点：调用者\"></a>相同点：调用者</h1>\n    <pre><code class=\"lang-python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestClass</span><span class=\"hljs-params\">()</span>:</span>\n\n<span class=\"hljs-meta\">    @classmethod</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">class_foo</span><span class=\"hljs-params\">(cls)</span>:</span>\n        print(cls)\n        print(<span class=\"hljs-string\">'test in class_foo'</span>)\n\n<span class=\"hljs-meta\">    @staticmethod</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">static_foo</span><span class=\"hljs-params\">()</span>:</span>\n        print(<span class=\"hljs-string\">'test in static_foo'</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    test = TestClass()\n    test.class_foo()\n    test.static_foo()\n    TestClass.class_foo()\n    TestClass.static_foo()\n</code></pre>\n<p>输出：</p>\n<pre><code>&lt;class &#39;__main__.TestClass&#39;&gt;\ntest in class_foo\ntest in static_foo\n&lt;class &#39;__main__.TestClass&#39;&gt;\ntest in class_foo\ntest in static_foo\n</code></pre><p>无论是<code>@classmethod</code>还是<code>@staticmethod</code>  的调用者，即可以为一个已经是实例化的对象，也可以的是为一个类名，这一点上与 JAVA 或 C++ 的静态函数有点相似</p>\n<h1 id=\"主要区别：参数要求\"><a href=\"#主要区别：参数要求\" class=\"headerlink\" title=\"主要区别：参数要求\"></a>主要区别：参数要求</h1><p><code>@classmethod</code> 比 <code>@staicmethod</code> 多要求一个参数，而多处的这个参数 <code>cls</code> 指代的就是调用者的类。从上一个例子可以看出，<code>cls</code>实际上指代的就是调用者的类型，即<code>test</code>的类型为<code>TestClass</code>。</p>\n<h1 id=\"应用举例\"><a href=\"#应用举例\" class=\"headerlink\" title=\"应用举例\"></a>应用举例</h1><h2 id=\"构造多个-constructor（构造函数）\"><a href=\"#构造多个-constructor（构造函数）\" class=\"headerlink\" title=\"构造多个 constructor（构造函数）\"></a>构造多个 constructor（构造函数）</h2><p>对于 C++ 以及 JAVA 函数来说，由于存在重载机制，因此可以多个构造函数。比如在 JAVA 的 Test 类中，我可以声明一个用数组初始化的构造函数，也可以声明一个由字符串初始化的构造函数。但由于 Python 没有这种机制，貌似有点棘手。但可以用 @classmethod 弥补。</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestClass</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self, lst)</span>:</span>\n        self.lst = lst\n\n<span class=\"hljs-meta\">    @classmethod</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">from_str</span><span class=\"hljs-params\">(cls, s)</span>:</span>\n        lst = s.split()\n        <span class=\"hljs-keyword\">return</span> cls(lst)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    t = TestClass([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])\n    print(t.lst)\n    t = TestClass.from_str(<span class=\"hljs-string\">\"1 2 3\"</span>)\n    print(t.lst)\n</code></pre>\n<p>输出：</p>\n<pre><code>[1, 2, 3]\n[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]\n</code></pre><p>而如果用 @staticmethod 则显得无力了</p>\n<h2 id=\"构造工厂类\"><a href=\"#构造工厂类\" class=\"headerlink\" title=\"构造工厂类\"></a>构造工厂类</h2><p>借助上面的特性，可以把在实际编写中写出一些简单的工厂类</p>\n<pre><code>class Diagram():\n    @classmethod\n    def make_circle(Class, color):\n        return Class.Circle(color)\n\n    @classmethod\n    def make_square(Class, color):\n        return Class.Circle(color)\n\n    class Circle():\n        def __init__(self, color):\n            self.color = color\n\n    class Square():\n        def __init__(self, color):\n            self.color = color\n\nclass AnotherDiagram():\n    @classmethod\n    def make_circle(Class, color):\n        return Class.Circle(color)\n\n    @classmethod\n    def make_square(Class, color):\n        return Class.Circle(color)\n\n    class Circle():\n        def __init__(self, color):\n            self.color = color\n\n    class Square():\n        def __init__(self, color):\n            self.color = color\n\nif __name__ == &quot;__main__&quot;:\n    factory = Diagram\n    d_circle = factory.make_circle(&quot;red&quot;)\n    d_square = factory.make_square(&quot;green&quot;)\n\n    factory = AnotherDiagram\n    ad_circle = factory.make_circle(&quot;violet&quot;)\n    ad_square = factory.make_square(&quot;pink&quot;)\n    print(d_circle.color, d_square.color, ad_circle.color, ad_square.color)\n</code></pre><p>例子中有两个工厂类：Diagram 和 AnotherDiagram 代表两种图表，两种图表都有 Circle 和Square 。另外值得注意的是，因为命名空间的原因，可以分别在两个工厂内声明 Circle 类和 Square 类。而不用大费力气的声明成这样：</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DiagramCirle</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DiagramSquare</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnotherDiagramCircle</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnotherDiagramSquare</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">pass</span>\n</code></pre>\n<p>运用 @classmethod 的工厂方式可读性显得更佳。而且在 factory 调用函数，不需要知道自己是 Diagram 或 AnotherDiagram，直接调用需要的绘图方法即可。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://book.douban.com/subject/25955274/\" target=\"_blank\" rel=\"external\">Python编程实战 运用设计模式、并发和程序库创建高质量程序</a> / Python in Practice: Create Better Programs Using Concurrency, Libraries, and Patterns</li>\n<li><a href=\"http://stackoverflow.com/questions/12179271/python-classmethod-and-staticmethod-for-beginner/14605349\" target=\"_blank\" rel=\"external\">Stack Overflow - Python @classmethod and @staticmethod for beginner?</a></li>\n<li><a href=\"https://www.zhihu.com/question/20021164\" target=\"_blank\" rel=\"external\">知乎 - Python 中的 classmethod 和 staticmethod 有什么具体用途？</a></li>\n</ol>\n","categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]}